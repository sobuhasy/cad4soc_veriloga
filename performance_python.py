#!/usr/bin/env python

import numpy as np
import matplotlib.pyplot as plt
from StringIO import StringIO
from scipy.fftpack import fft
import math

# open data file generated by Virtuoso
with open('adc_raw_output.csv', 'r') as f:
    adc_raw_output_csv = f.readlines()

# read parameters from data file
firstPole, inputFreq, clkPeriod, tRiseFall = adc_raw_output_header = np.genfromtxt(StringIO(adc_raw_output_csv[0]), delimiter=',', usecols=(1, 3, 5, 7), unpack=True)
adc_raw_output = np.genfromtxt(StringIO(''.join(adc_raw_output_csv[1:])), delimiter=',', skip_header=1, dtype=np.int32)

print "First Pole:\t\t\t%d" % firstPole
print "Input Frequency:\t\t%d Hz" % inputFreq
print "Sample Frequency:\t\t%d Hz" % (1./clkPeriod)

# setup fft calculation
sampleFreq = 1/clkPeriod
nPeriods = int(5/(clkPeriod*inputFreq))

N = 1024
x = (adc_raw_output[-N:])

# calculate fft
# source: https://github.com/MTG/sms-tools/blob/master/software/models/dftModel.py

hN = (N/2)+1                                            # size of positive spectrum, it includes sample 0
fftbuffer = np.zeros(N)                                 # initialize buffer for FFT
fftbuffer = x / (1.*N)                                  # normalize analysis window
X = fft(fftbuffer)                                      # compute FFT
absX = abs(X[:hN])                                      # compute ansolute value of positive side
absX[1:] = absX[1:]*2.                                  # normalize frequencies above DC
absX[absX<np.finfo(float).eps] = np.finfo(float).eps    # if zeros add epsilon to handle log
mX = 20 * np.log10(absX)                                # magnitude spectrum of positive frequencies in dB

# calculate index of fundamental and harmonics
fftFrequencies = np.round(np.arange(mX.size)*(sampleFreq/N))
freqResolution = sampleFreq/N
indexComponents = np.arange(1, np.int(sampleFreq/2/inputFreq)+1)*int(inputFreq/freqResolution)

indexPresentComp = indexComponents[mX[indexComponents]>-89.]

# calculate total harmonic distortion (THD)
n_harmonics = 3 # same as Cadence's "Harmonics" less one

thd = np.sqrt(sum((10**((mX[indexComponents[1:1+n_harmonics]]-mX[indexComponents[0]])/20))**2))
thd_db = 20*np.log10(thd)
print "Total Harmonic Distortion:\t%.3f%%" % (thd*100.)
print "\t\t\t\t%.2f dB" % thd_db

# calculate noise level and signal-to-noise ratio (SNR)
bin_spread = 0

noise =10**(mX/20)
noise[np.arange(bin_spread+1)] = np.finfo(float).eps # no DC content
# remove signal content
for component in indexComponents:
    noise[component+bin_spread-np.arange(2*bin_spread+1)] = np.finfo(float).eps
noise = np.sqrt(sum(noise**2))
noise = 20*np.log10(noise)
print "Noise Floor:\t\t\t%.2f dB" % noise
snr = mX[indexComponents[0]] - noise
print "Signal to Noise Ratio:\t\t%.2f dB" % snr

# calculate residual level, signal-to-noise-and-distortion (SINAD) and
# effective number of bits (ENOB)
residual = 10**(mX/20)
residual[np.arange(bin_spread+1)] = np.finfo(float).eps # no DC content
residual[indexComponents[0]+bin_spread-np.arange(2*bin_spread+1)] = np.finfo(float).eps # no fundamental
residual = np.sqrt(sum(residual**2))
residual = 20*np.log10(residual)
print "Noise and Distortion:\t\t%.2f dB" % residual
sinad = mX[indexComponents[0]] - residual
print "SINAD:\t\t\t\t%.2f dB" % sinad
enob = (sinad-1.76)/6.02
print "Effective Number of Bits:\t%.3f" % enob

# make plots pretty
plt.style.use('ggplot')

# plot the sampled signal in the time domain
plt.subplot(211)
plt.plot(np.arange(nPeriods)*clkPeriod, adc_raw_output[-nPeriods:],
marker='.')
plt.xlim(0, nPeriods*clkPeriod)
plt.ylim(-1, 16)
plt.title('Sampled signal')
plt.xlabel('Time / s')
plt.ylabel('Amplitude / 1')

# plot the frequency spectrum of the sampled signal
plt.subplot(212)
plt.plot(fftFrequencies, mX, '-', fftFrequencies[indexPresentComp[0]], mX[indexPresentComp[0]], 'o',
fftFrequencies[indexPresentComp[1:]], mX[indexPresentComp[1:]], 'o')
plt.xlim(min(fftFrequencies), max(fftFrequencies))
plt.ylim(-80, 30)
plt.title('Frequency spectrum of sampled signal')
plt.xlabel('Frequency / Hz')
plt.ylabel('Amplitude / dB')

plt.tight_layout()
plt.show()
